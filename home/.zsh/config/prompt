# prompt
# Load vcs_info, colors and init the prompt
autoload -Uz vcs_info
autoload -U colors && colors
autoload -U promptinit
promptinit

precmd_functions+=(vcs_info)

# Enable ONLY git and svn
zstyle ':vcs_info:*' enable git svn

# zstyle ':vcs_info:vcs_string:user-context:repo-root-name'
# * = wildcard

# Debugging of hooks system active?
zstyle ':vcs_info:*+*:*' debug false

# Only export one vcs_info_msg_*_ variable
zstyle ':vcs_info:*' max-exports 1

# Fetch current revision hsh (%i in expansion)
zstyle ':vcs_info:git*:*' get-revision false

# uncommited changes? (expansions %c [staged] and %u [unstaged])
zstyle ':vcs_info:git*:*' check-for-changes true

# string to be used when there are uncommitted changes and %u is expanded
zstyle ':vcs_info:git*:*' unstagedstr "%{$fg[red]%}✘%{$reset_color%}"
  
# Message format (expansions) to be used when "actionformats" is not used (most of the time)
# - current branch
# - unstagedstr expansion (see above))
# - misc git messages
zstyle ':vcs_info:git*' formats "%b%u%m"

# Format (expansion) used when in interactive rebase or merge
# See above
zstyle ':vcs_info:git*' actionformats "%b%u%m"

# restore original branch format output in SVN
zstyle ':vcs_info:svn*' branchformat "%b"
zstyle ':vcs_info:svn*' formats "%b%m"
zstyle ':vcs_info:svn*' actionformats "%b%m"

# set hooks used when a vcs_info_msg_*_ variable is set
# format is: :vcs_info:vcs_string+hookname:user-context
# function called are automatically prefixed with "+vi-"
# returning non-zero from those functions will cancel all other after that function
#
# use user_data (assoc array to communicate between hook functions):
# in one hook: user_data[key]=$value
# in the other ${user_data[key]} to use it
#
# special variables in hook functions:
# ret: default 0 -> the return value of the function. non-zero will cancel all functions after the returning one
# hook_com: assoc array -> bidirecional communication between caller (aka. vcs_info hook) and hook function. 
# Keys vary per vcs_info hook.
# context: active context of the hook (local context first!)
# vcs: current vcs_string
#
# the set-message hook has these parameters in hook_com:
# ‘action’, ‘branch’, ‘base’, ‘base-name’, ‘subdir’, ‘staged’, ‘unstaged’, ‘revision’, ‘misc’, ‘vcs’
zstyle ':vcs_info:git*+set-message:*' hooks git-st git-stash git-status

# Show remote ref name and number of commits ahead-of or behind
# See http://eseth.org/2010/git-in-zsh
function +vi-git-st() {
    local ahead behind remote
    local -a gitstatus

    # Are we on a remote-tracking branch?
    remote=${$(git rev-parse --verify ${hook_com[branch]}@{upstream} --symbolic-full-name 2>/dev/null)/refs\/remotes\/}

    if [[ -n "${remote}" ]] ; then
        ahead=$(git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l | sed 's/ //g')
        (( $ahead )) && gitstatus+=( "%{$fg[green]%}+${ahead}%{$reset_color%}" )

        behind=$(git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l | sed 's/ //g')
        (( $behind )) && gitstatus+=( "%{$fg[red]%}-${behind}%{$reset_color%}" )

        (( !$ahead && !$behind )) && gitstatus+=( "%{$fg[green]%}◷%{$reset_color%}" )
    else
      GIT_CURRENT_BRANCH=$(git name-rev --name-only HEAD)

      # check if on a existing (commited) ref
      refs=$(git show-ref | grep origin/${GIT_CURRENT_BRANCH} 2>/dev/null)
      if [[ "$refs" != "" ]]; then
        ahead=$(git log origin/$GIT_CURRENT_BRANCH..$GIT_CURRENT_BRANCH --oneline | wc -l | sed "s/ //g")
      else
        ahead="0"
      fi

      if [[ "$ahead" != "0" ]]; then
        gitstatus+=( "%{$fg[green]%}+${ahead}%{$reset_color%}" )
      else
        gitstatus+=( "%{$fg[green]%}◷%{$reset_color%}" )
      fi
    fi

    # the ${} uses parameter expansion 
    # (see http://zsh.sourceforge.net/Doc/Release/Expansion.html#Parameter-Expansion-1)
    # (j:/:) means: Join the array gitstatus with / as the delimiter
    hook_com[misc]+=",${(j:/:)gitstatus}"
}

# Show count of stashed changes
# See http://eseth.org/2010/git-in-zsh
function +vi-git-stash() {
    local -a stashes

    if [[ -s ${hook_com[base]}/.git/refs/stash ]] ; then
        stashes=$(git stash list 2>/dev/null | wc -l | sed 's/ //g')
        hook_com[misc]+=",${stashes} ✄ "
    fi
}

function +vi-git-status() {
  if [ -f ".git/BISECT_LOG" ] ; then
    hook_com[misc]+=",BISECT"
  elif [ -f ".git/MERGE_HEAD" ] ; then
    hook_com[misc]+=",MERGE"
  else
    for dir in rebase rebase-apply rebase-merge ; do
      if [ -d ".git/$dir" ] ; then
        hook_com[misc]+=",REBASE"
        break
      fi
    done
  fi
}

vcs_bracket() {
  # Only if in versioned dir
  if [[ ${vcs_info_msg_0_} != "" ]] ; then
    echo "[${vcs_info_msg_0_}]"
  fi
}

PS1='%{%(!~$fg[red]~$fg[green])%}%(4~|…|)%2~%{$reset_color%}$(vcs_bracket)%(!.#.)%{$reset_color%}> '
#with username: PS1='%{$fg[cyan]%}%n%{$fg[green]%}:%(4~|...|)%2~%{$reset_color%}$(vcs_bracket)%(!.#.)%{$reset_color%}> '

function rbenv_prompt_info() {
  local ruby_version
  ruby_version=$(rbenv version 2> /dev/null) || return
  echo "$ruby_version" | sed 's/[ \t].*$//'
}

RPROMPT='%{$fg_no_bold[blue]%}$(rbenv_prompt_info)%{$reset_color%}'
# vim:ft=sh
